/*******************************************************************************
 * Copyright (c) 2006-2010 eBay Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *******************************************************************************/
package org.ebayopensource.turmeric.plugins.maven.utils;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Properties;

import org.apache.commons.io.IOUtils;
import org.apache.maven.plugin.logging.Log;
import org.codehaus.plexus.util.StringUtils;

/**
 * Utility method to aide in working with timestamps of generation.
 * This helps in preventing m2eclipse from going into a endless build loop.
 * And it helps with detecting changes in a variety of files to know if a 
 * generation is needed. 
 */
public class GenTimestamp {
	public static final long NOT_SET = 0;
	private Log log;
	private File file;
	private Properties props;

	/**
	 * Construct a GenTimestamp object.
	 * 
	 * @param log
	 *            the log to use
	 * @param file
	 *            the file containing the timestamps
	 */
	public GenTimestamp(Log log, File file) {
		this.log = log;
		this.file = file;
		this.props = new Properties();

		if (file.exists()) {
			FileReader reader = null;
			try {
				reader = new FileReader(file);
				props.load(reader);
			} catch (IOException e) {
				this.log.warn("Unable to read timestamp file: " + file, e);
			} finally {
				IOUtils.closeQuietly(reader);
			}
		}
	}

	/**
	 * Write the timestamp file back out to disk.
	 */
	public void write() {
		FileWriter writer = null;
		try {
			writer = new FileWriter(file, false);
			props.store(writer, "Generated by turmeric-maven-plugin");
		} catch (IOException e) {
			this.log.warn("Unable to write timestamp file: " + file, e);
		}
	}

	/**
	 * Get the raw timestamp for a specific key.
	 * 
	 * @param key
	 * @return
	 */
	public long getTimestamp(String key) {
		String raw = props.getProperty(key);
		if (StringUtils.isBlank(raw)) {
			return NOT_SET;
		}
		try {
			return Long.parseLong(raw);
		} catch (NumberFormatException e) {
			this.log.warn("Cannot parse long integer [" + raw + "]");
			return NOT_SET;
		}
	}

	/**
	 * Test the timestamp key against the provided files. If any of the provided
	 * files are newer than the timestamp of the stored key, then return true.
	 * 
	 * @param key
	 *            the timestamp key to check.
	 * @param paths
	 *            the files to test. 
	 *            null paths are ignored. 
	 *            paths that don't exist are quietly skipped.
	 *            paths that exist, but are directories, are logged and skipped.
	 * @return true if any provided path is newer than the stored timestamp.
	 */
	public boolean isNewerThan(String key, File... paths) {
		long timestamp = getTimestamp(key);
		if (timestamp == NOT_SET) {
			return true;
		}

		for (File path : paths) {
			if ((path == null) || (!path.exists())) {
				// skip
				continue;
			}

			if (path.isDirectory()) {
				this.log.warn("Not testing for timestamp.isNewerThan() on directories: " + path);
				// skip
				continue;
			}

			if (path.lastModified() > timestamp) {
				this.log.info("Detected changed file: " + path);
				return true;
			}
		}

		return false;
	}
}
